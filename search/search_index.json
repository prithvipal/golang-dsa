{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Data Structures and Algorithms using Golang Data Structures and Algorithms using Golang provides code implemention for DSA problem statements in golang . It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Home"},{"location":"index.html#data-structures-and-algorithms-using-golang","text":"Data Structures and Algorithms using Golang provides code implemention for DSA problem statements in golang . It shows time and space complexity for each solution. It does not explain theoretical concepts of DSA but providers different level(Naive, Efficient and More Efficient) of programming solution for problem statement.","title":"Data Structures and Algorithms using Golang"},{"location":"about.html","text":"About Prithvipal Singh Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He likes to contribute in open source code. He is an author of Hands on go programming book. Let us connect. LinkedIn Twiter Github","title":"About Author"},{"location":"about.html#about-prithvipal-singh","text":"Prithvipal Singh is software engineer having more than 8 years of experience. He is experience in Golang, Java, Kubernetes, Docker, Microservice architecture, Cloud Computing. Currently, he is exploring edge computing. He likes to contribute in open source code. He is an author of Hands on go programming book. Let us connect. LinkedIn Twiter Github","title":"About Prithvipal Singh"},{"location":"array/count_inversion_in_array.html","text":"Count Inversion in An Array Explaination A pair (arr[i], arr[j]) form an inversion when: i < j and arr[i] > arr[j] Examples Input: [12, 14, 11, 13, 15] Output: 3 Explaination: (14, 11), (14, 13), (12, 11) Input: [11, 22, 44, 55] Output: 0 Explaination: Array elements are sorted in increasing order then output will be zero Input: [44, 33, 22, 11] Output: 6 Explaination: Array elements are sorted in decreasing order then output will be maximum possible (44, 33), (44, 22), (44, 11), (33, 22), (33, 11), (22, 11) Naive Solution package main import ( \"fmt\" ) func main() { arr := []int{12, 14, 11, 13, 15} // output = 3 // arr := []int{11, 22, 44, 55} // output = 0 // arr := []int{44, 33, 22, 11} // output = 6 res := inversionCount(arr) fmt.Println(res) } func inversionCount(arr []int) int { res := 0 for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { res++ } } } return res } Time Complexity: O(n * n) Efficient Solution Implementation The idea is based on merge sort We divide the array into two halves and we sort these two halves recursively then we merge these two halves. We count inversion while sorting the array We count inversion in left half We count inversion in right half While merging, we count inversion where one element is from left half and one element from right half Every inversion (x,y) where x>y has three possibity 1. Both x & y are in left half 2. Both x & y are in right half 3. x is in left half and y is in right half package main import ( \"fmt\" ) func main() { arr := []int{12, 14, 11, 13, 15} // output = 3 // arr := []int{11, 22, 44, 55} // output = 0 // arr := []int{44, 33, 22, 11} // output = 6 res := inversionCount(arr, 0, len(arr)-1) fmt.Println(res) } func inversionCount(arr []int, l, r int) int { res := 0 if r > l { m := (l + r) / 2 res += inversionCount(arr, l, m) res += inversionCount(arr, m+1, r) res += countAndMerge(arr, l, m, r) } return res } func countAndMerge(arr []int, low, mid, high int) int { n1 := mid - low + 1 n2 := high - mid left := make([]int, n1) right := make([]int, n2) for i := 0; i < n1; i++ { left[i] = arr[low+i] } for i := 0; i < n2; i++ { right[i] = arr[mid+i+1] } res := 0 i := 0 j := 0 k := low for i < n1 && j < n2 { if left[i] < right[j] { arr[k] = left[i] i++ } else { arr[k] = right[j] j++ // when an element found smaller in right array, // it means all element from ith in element of left array are also greater than that element. // so number inversion will also be number of element in left array from ith index res = res + n1 - i } k++ } for i < n1 { arr[k] = left[i] i++ k++ } for j < n2 { arr[k] = right[j] j++ k++ } return res } Time Complexity: O(n * log n) Aux Space Complexity: O(n) Dry Run: -- TO BE DONE","title":"Count Inversion in An Array"},{"location":"array/count_inversion_in_array.html#count-inversion-in-an-array","text":"","title":"Count Inversion in An Array"},{"location":"array/count_inversion_in_array.html#explaination","text":"A pair (arr[i], arr[j]) form an inversion when: i < j and arr[i] > arr[j]","title":"Explaination"},{"location":"array/count_inversion_in_array.html#examples","text":"Input: [12, 14, 11, 13, 15] Output: 3 Explaination: (14, 11), (14, 13), (12, 11) Input: [11, 22, 44, 55] Output: 0 Explaination: Array elements are sorted in increasing order then output will be zero Input: [44, 33, 22, 11] Output: 6 Explaination: Array elements are sorted in decreasing order then output will be maximum possible (44, 33), (44, 22), (44, 11), (33, 22), (33, 11), (22, 11)","title":"Examples"},{"location":"array/count_inversion_in_array.html#naive-solution","text":"package main import ( \"fmt\" ) func main() { arr := []int{12, 14, 11, 13, 15} // output = 3 // arr := []int{11, 22, 44, 55} // output = 0 // arr := []int{44, 33, 22, 11} // output = 6 res := inversionCount(arr) fmt.Println(res) } func inversionCount(arr []int) int { res := 0 for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { res++ } } } return res } Time Complexity: O(n * n)","title":"Naive Solution"},{"location":"array/count_inversion_in_array.html#efficient-solution","text":"","title":"Efficient Solution"},{"location":"array/count_inversion_in_array.html#implementation","text":"The idea is based on merge sort We divide the array into two halves and we sort these two halves recursively then we merge these two halves. We count inversion while sorting the array We count inversion in left half We count inversion in right half While merging, we count inversion where one element is from left half and one element from right half Every inversion (x,y) where x>y has three possibity 1. Both x & y are in left half 2. Both x & y are in right half 3. x is in left half and y is in right half package main import ( \"fmt\" ) func main() { arr := []int{12, 14, 11, 13, 15} // output = 3 // arr := []int{11, 22, 44, 55} // output = 0 // arr := []int{44, 33, 22, 11} // output = 6 res := inversionCount(arr, 0, len(arr)-1) fmt.Println(res) } func inversionCount(arr []int, l, r int) int { res := 0 if r > l { m := (l + r) / 2 res += inversionCount(arr, l, m) res += inversionCount(arr, m+1, r) res += countAndMerge(arr, l, m, r) } return res } func countAndMerge(arr []int, low, mid, high int) int { n1 := mid - low + 1 n2 := high - mid left := make([]int, n1) right := make([]int, n2) for i := 0; i < n1; i++ { left[i] = arr[low+i] } for i := 0; i < n2; i++ { right[i] = arr[mid+i+1] } res := 0 i := 0 j := 0 k := low for i < n1 && j < n2 { if left[i] < right[j] { arr[k] = left[i] i++ } else { arr[k] = right[j] j++ // when an element found smaller in right array, // it means all element from ith in element of left array are also greater than that element. // so number inversion will also be number of element in left array from ith index res = res + n1 - i } k++ } for i < n1 { arr[k] = left[i] i++ k++ } for j < n2 { arr[k] = right[j] j++ k++ } return res } Time Complexity: O(n * log n) Aux Space Complexity: O(n) Dry Run: -- TO BE DONE","title":"Implementation"},{"location":"array/frequency_sorted_array.html","text":"Frequency in a Sorted Array Input: arr[] = {12, 12, 12, 23, 43, 43} Output: 12 -> 3 23 -> 1 43 -> 2 Input: arr[] = {14, 14, 14, 14} Output: 14 -> 4 Input: arr[] = {101, 102, 103} Output: 101 -> 1 102 -> 1 103 -> 1 Implementation package main import \"fmt\" func main() { arr := []int{10} // arr := []int{12, 12, 12, 23, 43, 43} // arr := []int{14, 14, 14, 14} // arr := []int{101, 102, 103} printFreq(arr) } func printFreq(arr []int) { freq := 1 i := 1 for i < len(arr) { for i < len(arr) && arr[i] == arr[i-1] { i++ freq++ } fmt.Printf(\"%d -> %d\\n\", arr[i-1], freq) i++ freq = 1 } if len(arr) == 1 || arr[i-2] != arr[i-3] { fmt.Printf(\"%d --> %d\\n\", arr[len(arr)-1], 1) } } Time Complexity: \u03b8(n) Note: Since we are increamenting i in both for loop (outer and inner). As soon as i becomes equal to n, the loop stops. So total number of iterations are inner+outer loops. Time complexity is exactly n.","title":"Frequency in Sorted Array"},{"location":"array/frequency_sorted_array.html#frequency-in-a-sorted-array","text":"Input: arr[] = {12, 12, 12, 23, 43, 43} Output: 12 -> 3 23 -> 1 43 -> 2 Input: arr[] = {14, 14, 14, 14} Output: 14 -> 4 Input: arr[] = {101, 102, 103} Output: 101 -> 1 102 -> 1 103 -> 1","title":"Frequency in a Sorted Array"},{"location":"array/frequency_sorted_array.html#implementation","text":"package main import \"fmt\" func main() { arr := []int{10} // arr := []int{12, 12, 12, 23, 43, 43} // arr := []int{14, 14, 14, 14} // arr := []int{101, 102, 103} printFreq(arr) } func printFreq(arr []int) { freq := 1 i := 1 for i < len(arr) { for i < len(arr) && arr[i] == arr[i-1] { i++ freq++ } fmt.Printf(\"%d -> %d\\n\", arr[i-1], freq) i++ freq = 1 } if len(arr) == 1 || arr[i-2] != arr[i-3] { fmt.Printf(\"%d --> %d\\n\", arr[len(arr)-1], 1) } } Time Complexity: \u03b8(n) Note: Since we are increamenting i in both for loop (outer and inner). As soon as i becomes equal to n, the loop stops. So total number of iterations are inner+outer loops. Time complexity is exactly n.","title":"Implementation"},{"location":"array/intersection_of_two_sorted_array.html","text":"Intersection of Two Sorted Array Input: a[] = {4, 6, 12, 12, 12, 17, 17, 34} b[] = { 6, 12, 13, 17, 40} Output: c[] = { 6, 12, 17} Input: a[] = {2, 2, 4, 4, 4} b[] = {2, 2, 2, 2, 4, 6, 7} Output: c[] = {2, 4} Naive Solution package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { for i := 0; i < len(a); i++ { if i > 0 && a[i] == a[i-1] { continue } for j := 0; j < len(b); j++ { if a[i] == b[j] { c = append(c, a[i]) break } } } return c } Time Complexity: O(m*n) Dry Run: a[] = {1, 20, 20, 40, 60} b[] = {2, 20, 20, 20} i=0 : j=0, 1, 2, 3 i=1 : j=0, 1 c[] = {20} i=2 : i=3 : j = 0, 1, 2, 3 i=4 : j = 0, 1, 2, 3 Efficient Solution package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if i > 0 && a[i-1] == a[i] { i++ continue } if a[i] < b[j] { i++ } else if a[i] > b[j] { j++ } else { c = append(c, a[i]) i++ j++ } } return c } Time Complexity: \u03b8(m+n) Dry Run: a[] = {10, 20, 20, 40, 60} b[] = {2, 20, 20, 20} Initially: i=0, j=0 1st Iteration: j=1 2nd Iteration: i=1 3rd Iteration: c[20], i=2, j=2 4th Iteration: i=3 5th Iteration: j=3 6th Iteration: j=4","title":"Intersection of Two Sorted Array"},{"location":"array/intersection_of_two_sorted_array.html#intersection-of-two-sorted-array","text":"Input: a[] = {4, 6, 12, 12, 12, 17, 17, 34} b[] = { 6, 12, 13, 17, 40} Output: c[] = { 6, 12, 17} Input: a[] = {2, 2, 4, 4, 4} b[] = {2, 2, 2, 2, 4, 6, 7} Output: c[] = {2, 4}","title":"Intersection of Two Sorted Array"},{"location":"array/intersection_of_two_sorted_array.html#naive-solution","text":"package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { for i := 0; i < len(a); i++ { if i > 0 && a[i] == a[i-1] { continue } for j := 0; j < len(b); j++ { if a[i] == b[j] { c = append(c, a[i]) break } } } return c } Time Complexity: O(m*n) Dry Run: a[] = {1, 20, 20, 40, 60} b[] = {2, 20, 20, 20} i=0 : j=0, 1, 2, 3 i=1 : j=0, 1 c[] = {20} i=2 : i=3 : j = 0, 1, 2, 3 i=4 : j = 0, 1, 2, 3","title":"Naive Solution"},{"location":"array/intersection_of_two_sorted_array.html#efficient-solution","text":"package main import \"fmt\" func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := intersection(a, b) fmt.Println(res) //[5 10 15] } func intersection(a, b []int) (c []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if i > 0 && a[i-1] == a[i] { i++ continue } if a[i] < b[j] { i++ } else if a[i] > b[j] { j++ } else { c = append(c, a[i]) i++ j++ } } return c } Time Complexity: \u03b8(m+n) Dry Run: a[] = {10, 20, 20, 40, 60} b[] = {2, 20, 20, 20} Initially: i=0, j=0 1st Iteration: j=1 2nd Iteration: i=1 3rd Iteration: c[20], i=2, j=2 4th Iteration: i=3 5th Iteration: j=3 6th Iteration: j=4","title":"Efficient Solution"},{"location":"array/intro.html","text":"Introduction of Array Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction"},{"location":"array/intro.html#introduction-of-array","text":"Continuous memory allocation Advantages Random Access Cache friendliness","title":"Introduction of Array"},{"location":"array/is_array_sorted.html","text":"Check If An Array is Sorted Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above Naive Approach package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Check If Array is Sorted"},{"location":"array/is_array_sorted.html#check-if-an-array-is-sorted","text":"Input: arr[] = {18, 25, 27} Output: Yes Input: arr[] = {18, 30, 30, 99} Output: Yes Input: arr[] = {100} Output: Yes Input: arr[] = {100, 20, 200} Output: No Note - We are only considering array wheree array are in assending order - It there are duplicate then is also true. Ex. 2nd example above","title":"Check If An Array is Sorted"},{"location":"array/is_array_sorted.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes // arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { if arr[i] > arr[j] { return false } } } return true } Time Complexity: O(n2)","title":"Naive Approach"},{"location":"array/is_array_sorted.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 25, 27} // Yes // arr := []int{18, 30, 30, 99} // Yes // arr := []int{100} // Yes arr := []int{100, 20, 200} // No result := isArraySorted(arr) if result { fmt.Println(\"Yes\") } else { fmt.Println(\"No\") } } func isArraySorted(arr []int) bool { for i := 0; i < len(arr)-2; i++ { if arr[i] > arr[i+1] { return false } } return true } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/largest_element.html","text":"Largest element in array package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest Element in Array"},{"location":"array/largest_element.html#largest-element-in-array","text":"package main import \"fmt\" func main() { arr := []int{10, 52, 18, 20} largest := getLargest(arr) fmt.Println(\"largest element at index\", largest) fmt.Println(\"largest element\", arr[largest]) } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } Time Complexity: O(n)","title":"Largest element in array"},{"location":"array/leaders_in_array.html","text":"Leaders in an Array Input: arr[] = {17, 20, 14, 13, 16, 15, 12} Output: {20, 16, 15, 12} Input: arr[] = {10, 20, 30} Output: {30} Input: arr[] = {25, 15, 10} Output: {25, 15, 10} Leader in an array is the element that there is no larger than the element to its right side. Left most is always be leader because there is no large then that element to its right side. If there are duplicate elements then first occurance can be considers as leader. We can consider last occurance because we are say larger but not equal. Ex: {9, 11, 6, 11, 8, 7, 2} :: here can not consider 11 of 1st index. we can condier 11 of 3rd index. Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{17, 20, 14, 13, 16, 15, 12} // 20 16 15 12 // arr := []int{10, 20, 30} // 30 arr := []int{25, 15, 10} leader(arr) } func leader(arr []int) { for i := 0; i < len(arr); i++ { flag := false for j := i + 1; j < len(arr); j++ { if arr[i] <= arr[j] { flag = true break } } if !flag { fmt.Printf(\"%d \", arr[i]) } } fmt.Println() } Time Complexity: O(n 2 ) Efficient Approach package main import ( \"fmt\" ) func main() { arr := []int{17, 20, 14, 13, 16, 15, 12} // 12 15 16 20 // arr := []int{10, 20, 30} // 30 // arr := []int{25, 15, 10} // 10 15 25 leader(arr) } func leader(arr []int) { curLeader := arr[len(arr)-1] fmt.Printf(\"%d \", curLeader) for i := len(arr) - 2; i >= 0; i-- { if curLeader < arr[i] { curLeader = arr[i] fmt.Printf(\"%d \", curLeader) } } fmt.Println() } Time Complexity: \u03b8(n) Note: It will print leaders in reverse order If we want to print in same order as we have in array, then we can store leaders in a new array and then we can iterate new array in reverse order and print each element.","title":"Leaders in Array"},{"location":"array/leaders_in_array.html#leaders-in-an-array","text":"Input: arr[] = {17, 20, 14, 13, 16, 15, 12} Output: {20, 16, 15, 12} Input: arr[] = {10, 20, 30} Output: {30} Input: arr[] = {25, 15, 10} Output: {25, 15, 10} Leader in an array is the element that there is no larger than the element to its right side. Left most is always be leader because there is no large then that element to its right side. If there are duplicate elements then first occurance can be considers as leader. We can consider last occurance because we are say larger but not equal. Ex: {9, 11, 6, 11, 8, 7, 2} :: here can not consider 11 of 1st index. we can condier 11 of 3rd index.","title":"Leaders in an Array"},{"location":"array/leaders_in_array.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{17, 20, 14, 13, 16, 15, 12} // 20 16 15 12 // arr := []int{10, 20, 30} // 30 arr := []int{25, 15, 10} leader(arr) } func leader(arr []int) { for i := 0; i < len(arr); i++ { flag := false for j := i + 1; j < len(arr); j++ { if arr[i] <= arr[j] { flag = true break } } if !flag { fmt.Printf(\"%d \", arr[i]) } } fmt.Println() } Time Complexity: O(n 2 )","title":"Naive Approach"},{"location":"array/leaders_in_array.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{17, 20, 14, 13, 16, 15, 12} // 12 15 16 20 // arr := []int{10, 20, 30} // 30 // arr := []int{25, 15, 10} // 10 15 25 leader(arr) } func leader(arr []int) { curLeader := arr[len(arr)-1] fmt.Printf(\"%d \", curLeader) for i := len(arr) - 2; i >= 0; i-- { if curLeader < arr[i] { curLeader = arr[i] fmt.Printf(\"%d \", curLeader) } } fmt.Println() } Time Complexity: \u03b8(n) Note: It will print leaders in reverse order If we want to print in same order as we have in array, then we can store leaders in a new array and then we can iterate new array in reverse order and print each element.","title":"Efficient Approach"},{"location":"array/left_rotate_array_by_d.html","text":"Left Rotate Array by d Input: arr[] = {11, 22, 33, 44, 55} d = 2 Output: arr[] = {33, 44, 55, 11, 22} Input: arr[] = {11, 15, 33, 19} d = 3 Output: arr[] = {19, 11, 15, 33} We may assume that d <= No of elements in array If d > no of elements in array then we can simply d = d-n Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func leftRotate(arr []int, d int) { for i := 0; i < d; i++ { leftRotateOne(arr) } } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n * d) Aux Space: \u03b8(1) Better Approach package main import ( \"fmt\" ) func main() { arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] leftRotate(arr, 2) fmt.Println(arr) // arr := []int{11, 15, 33, 19} // [19 11 15 33] // leftRotate(arr, 3) // fmt.Println(arr) } func leftRotate(arr []int, d int) { var temp []int for i := 0; i < d; i++ { temp = append(temp, arr[i]) } for i := d; i < len(arr); i++ { arr[i-d] = arr[i] } for i := range temp { arr[len(arr)-d+i] = temp[i] } } Time Complexity: \u03b8(d+ (n-d) + d) = \u03b8(n+d) = \u03b8(n) d is smaller than n so ignore d Aux Space: \u03b8(d) Best Approach package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func reverve(arr []int, low, high int) { for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } func leftRotate(arr []int, d int) { reverve(arr, 0, d-1) reverve(arr, d, len(arr)-1) reverve(arr, 0, len(arr)-1) } Time Complexity: \u03b8(d + (n-d) + n) = \u03b8(2n) = \u03b8(n) Aux Space: \u03b8(1)","title":"Left Rotate Array by d"},{"location":"array/left_rotate_array_by_d.html#left-rotate-array-by-d","text":"Input: arr[] = {11, 22, 33, 44, 55} d = 2 Output: arr[] = {33, 44, 55, 11, 22} Input: arr[] = {11, 15, 33, 19} d = 3 Output: arr[] = {19, 11, 15, 33} We may assume that d <= No of elements in array If d > no of elements in array then we can simply d = d-n","title":"Left Rotate Array by d"},{"location":"array/left_rotate_array_by_d.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func leftRotate(arr []int, d int) { for i := 0; i < d; i++ { leftRotateOne(arr) } } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n * d) Aux Space: \u03b8(1)","title":"Naive Approach"},{"location":"array/left_rotate_array_by_d.html#better-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] leftRotate(arr, 2) fmt.Println(arr) // arr := []int{11, 15, 33, 19} // [19 11 15 33] // leftRotate(arr, 3) // fmt.Println(arr) } func leftRotate(arr []int, d int) { var temp []int for i := 0; i < d; i++ { temp = append(temp, arr[i]) } for i := d; i < len(arr); i++ { arr[i-d] = arr[i] } for i := range temp { arr[len(arr)-d+i] = temp[i] } } Time Complexity: \u03b8(d+ (n-d) + d) = \u03b8(n+d) = \u03b8(n) d is smaller than n so ignore d Aux Space: \u03b8(d)","title":"Better Approach"},{"location":"array/left_rotate_array_by_d.html#best-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [33 44 55 11 22] // leftRotate(arr, 2) // fmt.Println(arr) arr := []int{11, 15, 33, 19} // [19 11 15 33] leftRotate(arr, 3) fmt.Println(arr) } func reverve(arr []int, low, high int) { for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } func leftRotate(arr []int, d int) { reverve(arr, 0, d-1) reverve(arr, d, len(arr)-1) reverve(arr, 0, len(arr)-1) } Time Complexity: \u03b8(d + (n-d) + n) = \u03b8(2n) = \u03b8(n) Aux Space: \u03b8(1)","title":"Best Approach"},{"location":"array/left_rotate_array_by_one.html","text":"Left Rotate an Array by One Input: arr[] = {11, 22, 33, 44, 55} Output: arr[] = {22, 33, 44, 55, 11} Input: arr[] = {50, 3, 22} Output: arr[] = {3, 22, 50} package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [22 33 44 55 11] arr := []int{50, 3, 22} // [3 22 50] leftRotateOne(arr) fmt.Println(arr) } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n) Space Complexity: \u03b8(1)","title":"Left Rotate Array by One"},{"location":"array/left_rotate_array_by_one.html#left-rotate-an-array-by-one","text":"Input: arr[] = {11, 22, 33, 44, 55} Output: arr[] = {22, 33, 44, 55, 11} Input: arr[] = {50, 3, 22} Output: arr[] = {3, 22, 50} package main import ( \"fmt\" ) func main() { // arr := []int{11, 22, 33, 44, 55} // [22 33 44 55 11] arr := []int{50, 3, 22} // [3 22 50] leftRotateOne(arr) fmt.Println(arr) } func leftRotateOne(arr []int) { temp := arr[0] for i := 1; i < len(arr); i++ { arr[i-1] = arr[i] } arr[len(arr)-1] = temp } Time Complexity: \u03b8(n) Space Complexity: \u03b8(1)","title":"Left Rotate an Array by One"},{"location":"array/maximum_difference.html","text":"Maximum Differences Maximum value of a[j] > a[i] such that j>i Input: arr[] = {3, 4, 11, 7, 5, 9, 1} Outout: 8 Input: arr[] = {8, 10, 6, 7, 4, 2} Outout: 2 Input: arr[] = {20, 30, 40} Output: 20 Here array is sorted so max diff is last element minus first element. Input: arr[] = {40, 30, 6, 4} Output: -2 Here array is reverse sorted then output will be negative Naive Approach package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { result = max(result, arr[j]-arr[i]) } } return result } func max(a, b int) int { if a > b { return a } return b } Time complexity: \u03b8(n 2 ) Efficient Approach package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] minVal := arr[0] for i := 1; i < len(arr); i++ { result = max(result, arr[i]-minVal) minVal = min(minVal, arr[i]) } return result } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a < b { return a } return b } Time Complexity: \u03b8(n) Aux Space: \u03b8(1)","title":"Maximum Difference"},{"location":"array/maximum_difference.html#maximum-differences","text":"Maximum value of a[j] > a[i] such that j>i Input: arr[] = {3, 4, 11, 7, 5, 9, 1} Outout: 8 Input: arr[] = {8, 10, 6, 7, 4, 2} Outout: 2 Input: arr[] = {20, 30, 40} Output: 20 Here array is sorted so max diff is last element minus first element. Input: arr[] = {40, 30, 6, 4} Output: -2 Here array is reverse sorted then output will be negative","title":"Maximum Differences"},{"location":"array/maximum_difference.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] for i := 0; i < len(arr); i++ { for j := i + 1; j < len(arr); j++ { result = max(result, arr[j]-arr[i]) } } return result } func max(a, b int) int { if a > b { return a } return b } Time complexity: \u03b8(n 2 )","title":"Naive Approach"},{"location":"array/maximum_difference.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { arr := []int{3, 4, 11, 7, 5, 9, 1} // 8 // arr := []int{8, 10, 6, 7, 4, 2} // 2 // arr := []int{20, 30, 40} // 20 // arr := []int{40, 30, 6, 4} // -2 result := maxDiff(arr) fmt.Println(result) } func maxDiff(arr []int) int { result := arr[1] - arr[0] minVal := arr[0] for i := 1; i < len(arr); i++ { result = max(result, arr[i]-minVal) minVal = min(minVal, arr[i]) } return result } func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a < b { return a } return b } Time Complexity: \u03b8(n) Aux Space: \u03b8(1)","title":"Efficient Approach"},{"location":"array/move_all_zeroes_to_end.html","text":"Move All Zeroes to End Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66} Noive Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { for i := 0; i < len(arr); i++ { if arr[i] == 0 { for j := i + 1; j < len(arr); j++ { if arr[j] != 0 { arr[i], arr[j] = swap(arr[i], arr[j]) } } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n*n) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { count := 0 for i := 0; i < len(arr); i++ { if arr[i] != 0 { arr[i], arr[count] = swap(arr[i], arr[count]) count++ } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n)","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end.html#move-all-zeroes-to-end","text":"Input: arr[] = {18, 13, 0, 30, 0, 40} Output: arr[] = {18, 13, 30, 40, 0, 0} Input: arr[] = {0, 0, 0, 20, 0} Output: arr[] = {20, 0, 0, 0} Input: arr[] = {50, 66} Output: arr[] = {50, 66}","title":"Move All Zeroes to End"},{"location":"array/move_all_zeroes_to_end.html#noive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { for i := 0; i < len(arr); i++ { if arr[i] == 0 { for j := i + 1; j < len(arr); j++ { if arr[j] != 0 { arr[i], arr[j] = swap(arr[i], arr[j]) } } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n*n)","title":"Noive Approach"},{"location":"array/move_all_zeroes_to_end.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{18, 13, 0, 30, 0, 40} // [18 13 40 30 0 0] // arr := []int{0, 0, 0, 20, 0} // [20 0 0 0 0] arr := []int{50, 66} // [50 66] moveToEnd(arr) fmt.Println(arr) } func moveToEnd(arr []int) { count := 0 for i := 0; i < len(arr); i++ { if arr[i] != 0 { arr[i], arr[count] = swap(arr[i], arr[count]) count++ } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/operations.html","text":"Operations Search (unsorted array) package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Operation in Array"},{"location":"array/operations.html#operations","text":"","title":"Operations"},{"location":"array/operations.html#search-unsorted-array","text":"package main import \"fmt\" func main() { arr := []int{10, 3, 6, 14, 17} result := search(arr, 14) if result == -1 { fmt.Println(\"Element not found\") } else { fmt.Println(\"Element found at index:\", result) } } func search(arr []int, ele int) int { for i := 0; i < len(arr); i++ { if arr[i] == ele { return i } } return -1 } Time Complexity: O(n)","title":"Search (unsorted array)"},{"location":"array/remove_duplicates_from_sorted_array.html","text":"Remove Duplicates from Sorted Array Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1 Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n) Efficient Approach package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Remove Duplicate from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array.html#remove-duplicates-from-sorted-array","text":"Input: arr[] = {12, 15, 15, 20, 20, 20, 20} length: 7 Output: arr[] = {12, 15, 20} length: 3 Input: arr[] = {16, 16, 16} length: 3 Output: arr[] = {16} length: 1","title":"Remove Duplicates from Sorted Array"},{"location":"array/remove_duplicates_from_sorted_array.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { var temp []int temp = append(temp, arr[0]) result := 1 for i := 1; i < len(arr); i++ { if temp[result-1] != arr[i] { temp = append(temp, arr[i]) result++ } } for i := 0; i < result; i++ { arr[i] = temp[i] } return arr[:result] } Time Complexity: O(n) Space Complexity: O(n)","title":"Naive Approach"},{"location":"array/remove_duplicates_from_sorted_array.html#efficient-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 15, 15, 20, 20, 20, 20} // [12 15 20] arr := []int{16, 16, 16} // [16] result := removeDups(arr) fmt.Println(\"arr[] =\", result) fmt.Println(\"length =\", len(result)) } func removeDups(arr []int) []int { result := 1 for i := 1; i < len(arr); i++ { if arr[i] != arr[result-1] { arr[result] = arr[i] result++ } } return arr[:result] } Time Complexity: O(n) Space Complexity: O(1) Note: we are using result variable to keep track to unique elements in array.","title":"Efficient Approach"},{"location":"array/remove_duplicates_from_unsorted_array.html","text":"Remove Duplicates from Un-sorted Array Implementation package main import \"fmt\" func main() { arr := []int{10, 12, 8, 10, 12} result := removeDups(arr) fmt.Println(result) } func removeDups(arr []int) []int { var tempArr []int m := make(map[int]bool) for _, ele := range arr { if _, ok := m[ele]; !ok { m[ele] = true tempArr = append(tempArr, ele) } } return tempArr }","title":"Remove Duplicate from Unsorted Array"},{"location":"array/remove_duplicates_from_unsorted_array.html#remove-duplicates-from-un-sorted-array","text":"","title":"Remove Duplicates from Un-sorted Array"},{"location":"array/remove_duplicates_from_unsorted_array.html#implementation","text":"package main import \"fmt\" func main() { arr := []int{10, 12, 8, 10, 12} result := removeDups(arr) fmt.Println(result) } func removeDups(arr []int) []int { var tempArr []int m := make(map[int]bool) for _, ele := range arr { if _, ok := m[ele]; !ok { m[ele] = true tempArr = append(tempArr, ele) } } return tempArr }","title":"Implementation"},{"location":"array/reverse_array.html","text":"Reverse an Array Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33} Approach One package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1) Approach Two package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Reverse an Array"},{"location":"array/reverse_array.html#reverse-an-array","text":"Input: arr[] = {12, 7, 9, 33} Output arr[] = {33, 9, 7, 12} Input: arr[] = {33, 22, 9, 3, 99} Output: arr[] = {99, 3, 9, 22, 33}","title":"Reverse an Array"},{"location":"array/reverse_array.html#approach-one","text":"package main import ( \"fmt\" ) func main() { arr := []int{12, 7, 9, 33} // [33 9 7 12] // arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reserveArray(arr) fmt.Println(arr) } func reserveArray(arr []int) { low := 0 high := len(arr) - 1 for low < high { temp := arr[low] arr[low] = arr[high] arr[high] = temp low++ high-- } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach One"},{"location":"array/reverse_array.html#approach-two","text":"package main import ( \"fmt\" ) func main() { // arr := []int{12, 7, 9, 33} // [33 9 7 12] arr := []int{33, 22, 9, 3, 99} // [99 3 9 22 33 reverseArray(arr) fmt.Println(arr) } func reverseArray(arr []int) { for i := 0; i < len(arr)/2; i++ { temp := arr[i] j := len(arr) - i - 1 arr[i] = arr[j] arr[j] = temp } } Time Complexity: : \u03b8(n) Aux Space: \u03b8(1)","title":"Approach Two"},{"location":"array/second_largest_element.html","text":"Second Largest Element in Array Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element Naive Approach package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second } Efficient Approach arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Second Largest Element in Array"},{"location":"array/second_largest_element.html#second-largest-element-in-array","text":"Input: arr[] = {10, 5, 6, 15} Output: 0 // index of 10 Input: arr[] = {30, 15, 23, 9, 28} Output: 4 // index of 28 Inpute: arr[] = {15, 15, 15} Output: -1 // No second element","title":"Second Largest Element in Array"},{"location":"array/second_largest_element.html#naive-approach","text":"package main import ( \"fmt\" ) func main() { // arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getLargest(arr []int) int { largest := 0 for i := 1; i < len(arr); i++ { if arr[i] > arr[largest] { largest = i } } return largest } func getSecondLargest(arr []int) int { first := getLargest(arr) second := -1 for i := 0; i < len(arr); i++ { if arr[first] != arr[i] { if second == -1 { second = i } else if arr[second] < arr[i] { second = i } } } return second }","title":"Naive Approach"},{"location":"array/second_largest_element.html#efficient-approach","text":"arr[i] > arr[largest]: res = largest, largest = i arr[i] == arr[largest]: Ignore arr[i] < arr[largest]: res == -1: res = i arr[i] <= arr[res]: Ignore arr[i] > arr[res]: res = i package main import ( \"fmt\" ) func main() { arr := []int{10, 5, 6, 15} // arr := []int{30, 15, 23, 9, 28} // arr := []int{15, 15, 15} secLargest := getSecondLargest(arr) if secLargest == -1 { fmt.Println(\"No sencond largest found\") } else { fmt.Println(\"largest element at index\", secLargest) fmt.Println(\"largest element\", arr[secLargest]) } } func getSecondLargest(arr []int) int { first := 0 second := -1 for i := 1; i < len(arr); i++ { if arr[i] > arr[first] { second = first first = i } else if (second == -1 || arr[i] > arr[second]) && arr[i] != arr[first] { second = i } } return second } Time Complexity: O(n)","title":"Efficient Approach"},{"location":"array/sum_of_all_pair_in_sorted_array_is_equal_to_given_number.html","text":"Sum of All Pair in Sorted Array is Equal to Given Number Input arr := []int{1, 2, 3, 4, 5} sum:= 7 Output: [2 5] [3 4] Implementation package main import \"fmt\" func main() { arr := []int{1, 2, 3, 4, 5} result := getSumPairs(arr, 7) fmt.Println(result) } func getSumPairs(arr []int, sum int) [][2]int { i := 0 j := len(arr) - 1 result := make([][2]int, 0) for i < j { var pair [2]int addition := arr[i] + arr[j] if addition == sum { pair[0] = arr[i] pair[1] = arr[j] result = append(result, pair) i++ j-- } else if addition < sum { i++ } else { j-- } } return result }","title":"Sum of All Pair in Sorted Array is Equal to Given Number"},{"location":"array/sum_of_all_pair_in_sorted_array_is_equal_to_given_number.html#sum-of-all-pair-in-sorted-array-is-equal-to-given-number","text":"Input arr := []int{1, 2, 3, 4, 5} sum:= 7 Output: [2 5] [3 4]","title":"Sum of All Pair in Sorted Array is Equal to Given Number"},{"location":"array/sum_of_all_pair_in_sorted_array_is_equal_to_given_number.html#implementation","text":"package main import \"fmt\" func main() { arr := []int{1, 2, 3, 4, 5} result := getSumPairs(arr, 7) fmt.Println(result) } func getSumPairs(arr []int, sum int) [][2]int { i := 0 j := len(arr) - 1 result := make([][2]int, 0) for i < j { var pair [2]int addition := arr[i] + arr[j] if addition == sum { pair[0] = arr[i] pair[1] = arr[j] result = append(result, pair) i++ j-- } else if addition < sum { i++ } else { j-- } } return result }","title":"Implementation"},{"location":"array/union_of_two_sorted_array.html","text":"Union if Two Sorted Array Input: a[] = {13, 15, 18} b[] = {12, 18, 19, 20, 25} Output: c[] = {12, 13, 15, 18, 19, 20, 25} Input: a[] = {12, 13, 13, 13, 14, 14} b[] = {14, 14} Output: c[] = {12, 13, 14} Naive Approach package main import ( \"fmt\" \"sort\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { c := make([]int, len(a)+len(b)) for i := 0; i < len(a); i++ { c[i] = a[i] } m := len(a) for j := 0; j < len(b); j++ { c[m+j] = b[j] } sort.Ints(c) for i := 0; i < len(c); i++ { if i == 0 || c[i] != c[i-1] { res = append(res, c[i]) } } return res } Time Complexity: O((m+n)*log(m+n)) Dry Run: a[] = {3, 5, 5} b[] = {1, 5, 7, 7} After 1st loop: c[] = {3, 5, 5, , , , } After 2nd loop: c[] = {3, 5, 5, 1, 5, 7, 7} After sorting: c[] = {1, 3, 5, 5, 5, 7, 7} 3rd loop: res[] = {1, 3, 5, 7} Efficient Solution Implementation Idea if i > 0 && a[i] == a[i-1] { i++; continue; } if j > 0 && b[j] == b[j-1] { j++; continue; } if a[i] < b[j] { c=append(c,a[i]); i++ } if a[i] > b[j] { c=append(c,b[j]); j++ } if a[i] == b[j] { c=append(c,a[i]); i++; j++ } Implementation package main import ( \"fmt\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { m := len(a) n := len(b) i, j := 0, 0 for i < m && j < n { if i > 0 && a[i] == a[i-1] { i++ continue } if j > 0 && b[j] == b[j-1] { j++ continue } if a[i] < b[j] { res = append(res, a[i]) i++ } else if a[i] > b[j] { res = append(res, b[j]) j++ } else { res = append(res, a[i]) i++ j++ } } for i < m { if i == 0 || a[i] != a[i-1] { res = append(res, a[i]) } i++ } for j < n { if j == 0 || b[j] != b[j-1] { res = append(res, b[j]) } j++ } return } Dry Run a[] = {12, 20, 30, 30} b[] = {13, 30, 40} i=0; j=0; 1st Iteration: c[] = {12}, i=1 2nd Iteration: c[] = {12, 13}, j=1 3rd Iteration: c[] = {12, 13, 20}, i=2 4th Iteration: c[] = {12, 13, 20, 30}, i=3, j=2 5th Iteration: c[] = {12, 13, 20, 30}, i=4 Next Loop for(j < n) : c[] = {12, 13, 20, 30, 40}, j=3","title":"Union of Two Sorted Array"},{"location":"array/union_of_two_sorted_array.html#union-if-two-sorted-array","text":"Input: a[] = {13, 15, 18} b[] = {12, 18, 19, 20, 25} Output: c[] = {12, 13, 15, 18, 19, 20, 25} Input: a[] = {12, 13, 13, 13, 14, 14} b[] = {14, 14} Output: c[] = {12, 13, 14}","title":"Union if Two Sorted Array"},{"location":"array/union_of_two_sorted_array.html#naive-approach","text":"package main import ( \"fmt\" \"sort\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { c := make([]int, len(a)+len(b)) for i := 0; i < len(a); i++ { c[i] = a[i] } m := len(a) for j := 0; j < len(b); j++ { c[m+j] = b[j] } sort.Ints(c) for i := 0; i < len(c); i++ { if i == 0 || c[i] != c[i-1] { res = append(res, c[i]) } } return res } Time Complexity: O((m+n)*log(m+n)) Dry Run: a[] = {3, 5, 5} b[] = {1, 5, 7, 7} After 1st loop: c[] = {3, 5, 5, , , , } After 2nd loop: c[] = {3, 5, 5, 1, 5, 7, 7} After sorting: c[] = {1, 3, 5, 5, 5, 7, 7} 3rd loop: res[] = {1, 3, 5, 7}","title":"Naive Approach"},{"location":"array/union_of_two_sorted_array.html#efficient-solution","text":"","title":"Efficient Solution"},{"location":"array/union_of_two_sorted_array.html#implementation-idea","text":"if i > 0 && a[i] == a[i-1] { i++; continue; } if j > 0 && b[j] == b[j-1] { j++; continue; } if a[i] < b[j] { c=append(c,a[i]); i++ } if a[i] > b[j] { c=append(c,b[j]); j++ } if a[i] == b[j] { c=append(c,a[i]); i++; j++ }","title":"Implementation Idea"},{"location":"array/union_of_two_sorted_array.html#implementation","text":"package main import ( \"fmt\" ) func main() { a := []int{3, 5, 10, 10, 10, 15, 15, 20} b := []int{5, 10, 10, 15, 30} res := union(a, b) fmt.Println(res) //[3 5 10 15 20 30] } func union(a, b []int) (res []int) { m := len(a) n := len(b) i, j := 0, 0 for i < m && j < n { if i > 0 && a[i] == a[i-1] { i++ continue } if j > 0 && b[j] == b[j-1] { j++ continue } if a[i] < b[j] { res = append(res, a[i]) i++ } else if a[i] > b[j] { res = append(res, b[j]) j++ } else { res = append(res, a[i]) i++ j++ } } for i < m { if i == 0 || a[i] != a[i-1] { res = append(res, a[i]) } i++ } for j < n { if j == 0 || b[j] != b[j-1] { res = append(res, b[j]) } j++ } return } Dry Run a[] = {12, 20, 30, 30} b[] = {13, 30, 40} i=0; j=0; 1st Iteration: c[] = {12}, i=1 2nd Iteration: c[] = {12, 13}, j=1 3rd Iteration: c[] = {12, 13, 20}, i=2 4th Iteration: c[] = {12, 13, 20, 30}, i=3, j=2 5th Iteration: c[] = {12, 13, 20, 30}, i=4 Next Loop for(j < n) : c[] = {12, 13, 20, 30, 40}, j=3","title":"Implementation"},{"location":"bst/second_largest_number_from_given_number.html","text":"Second Largest Number from Given Number 45 / \\ 40 60 / \\ / \\ 20 42 50 70 In given above tree, if given number n as 70 then result should be 60 if given number n as 60 then result should be 45 if given number n as 43 then result should be 42 if given number n as 15 then result should be NOT FOUND Implementation package main import \"fmt\" type Tree struct { data int left *Tree right *Tree } func main() { root := &Tree{data: 45} root.left = &Tree{data: 40} root.left.left = &Tree{data: 20} root.left.right = &Tree{data: 42} root.right = &Tree{data: 60} root.right.left = &Tree{data: 50} root.right.right = &Tree{data: 70} result := secondLarge(root, 80) if result == nil { fmt.Println(\"Not Found\") } else { fmt.Println(*result) } } func secondLarge(root *Tree, n int) *int { if root == nil { return nil } var result *int if root.data < n { result = secondLarge(root.right, n) } else if root.data > n { result = secondLarge(root.left, n) } if result == nil || *result >= n { if root.data > n { return nil } return &root.data } return result }","title":"Second Largest Number from Given Number"},{"location":"bst/second_largest_number_from_given_number.html#second-largest-number-from-given-number","text":"45 / \\ 40 60 / \\ / \\ 20 42 50 70 In given above tree, if given number n as 70 then result should be 60 if given number n as 60 then result should be 45 if given number n as 43 then result should be 42 if given number n as 15 then result should be NOT FOUND","title":"Second Largest Number from Given Number"},{"location":"bst/second_largest_number_from_given_number.html#implementation","text":"package main import \"fmt\" type Tree struct { data int left *Tree right *Tree } func main() { root := &Tree{data: 45} root.left = &Tree{data: 40} root.left.left = &Tree{data: 20} root.left.right = &Tree{data: 42} root.right = &Tree{data: 60} root.right.left = &Tree{data: 50} root.right.right = &Tree{data: 70} result := secondLarge(root, 80) if result == nil { fmt.Println(\"Not Found\") } else { fmt.Println(*result) } } func secondLarge(root *Tree, n int) *int { if root == nil { return nil } var result *int if root.data < n { result = secondLarge(root.right, n) } else if root.data > n { result = secondLarge(root.left, n) } if result == nil || *result >= n { if root.data > n { return nil } return &root.data } return result }","title":"Implementation"},{"location":"concurrency/print_odd_even_sequentially.html","text":"Print Odd and Even Sequentially using Two Goroutine Using Two Channels package main import ( \"fmt\" \"sync\" ) func main() { n := 10 chOdd := make(chan bool) chEven := make(chan bool) var wg sync.WaitGroup wg.Add(2) go odd(n, chOdd, chEven, &wg) go even(n, chOdd, chEven, &wg) wg.Wait() } func odd(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= n; i = i + 2 { fmt.Println(i) chEven <- true <-chOdd } } func even(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 2; i <= n; i = i + 2 { <-chEven fmt.Println(i) chOdd <- true } } Output: 1 2 3 4 5 6 7 8 9 10 Using One Channel package main import ( \"fmt\" \"sync\" ) func main() { c := make(chan int) var wg sync.WaitGroup wg.Add(2) go odd(c, &wg) go even(c, &wg) wg.Wait() } func even(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { <-c if i%2 == 0 { fmt.Println(i) } } } func odd(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { c <- 1 if i%2 == 1 { fmt.Println(i) } } }","title":"Print Odd and Even Sequentially using goroutine"},{"location":"concurrency/print_odd_even_sequentially.html#print-odd-and-even-sequentially-using-two-goroutine","text":"","title":"Print Odd and Even Sequentially using Two Goroutine"},{"location":"concurrency/print_odd_even_sequentially.html#using-two-channels","text":"package main import ( \"fmt\" \"sync\" ) func main() { n := 10 chOdd := make(chan bool) chEven := make(chan bool) var wg sync.WaitGroup wg.Add(2) go odd(n, chOdd, chEven, &wg) go even(n, chOdd, chEven, &wg) wg.Wait() } func odd(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= n; i = i + 2 { fmt.Println(i) chEven <- true <-chOdd } } func even(n int, chOdd chan bool, chEven chan bool, wg *sync.WaitGroup) { defer wg.Done() for i := 2; i <= n; i = i + 2 { <-chEven fmt.Println(i) chOdd <- true } } Output: 1 2 3 4 5 6 7 8 9 10","title":"Using Two Channels"},{"location":"concurrency/print_odd_even_sequentially.html#using-one-channel","text":"package main import ( \"fmt\" \"sync\" ) func main() { c := make(chan int) var wg sync.WaitGroup wg.Add(2) go odd(c, &wg) go even(c, &wg) wg.Wait() } func even(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { <-c if i%2 == 0 { fmt.Println(i) } } } func odd(c chan int, wg *sync.WaitGroup) { defer wg.Done() for i := 1; i <= 10; i++ { c <- 1 if i%2 == 1 { fmt.Println(i) } } }","title":"Using One Channel"},{"location":"linked_list/add_one_linked_list_digit.html","text":"Add One in Lisked List Digit Input: |1| -> |3| -> |9| -> |9| Digit is: 1399 1399 + 1 = 1400 Output: |1| -> |4| -> |0| -> |0| Input: |9| -> |9| -> |9| -> |9| Output: |1| -> |0| -> |0| -> |0| -> |0| Implementation package main import \"fmt\" func main() { head := initialize(19999) head = addOne(head) printResult(head) } func initialize(n int) (head *Node) { var arr []int for n > 0 { data := n % 10 arr = append(arr, data) n = n / 10 } var curr *Node for i := len(arr) - 1; i >= 0; i-- { if i == len(arr)-1 { curr = &Node{data: arr[i]} head = curr } else { curr.next = &Node{data: arr[i]} curr = curr.next } } return head } func printResult(head *Node) { for head != nil { fmt.Print(head.data) head = head.next } fmt.Println() } type Node struct { data int next *Node } func addOne(head *Node) *Node { var stack []*Node curr := head for curr != nil { stack = append(stack, curr) curr = curr.next } carry := 1 for i := len(stack) - 1; i >= 0; i-- { ele := stack[i] add := ele.data + carry ele.data = add % 10 carry = add / 10 } if carry > 0 { newHead := &Node{data: carry} newHead.next = head return newHead } return head }","title":"Add One in Lisked List Digit"},{"location":"linked_list/add_one_linked_list_digit.html#add-one-in-lisked-list-digit","text":"Input: |1| -> |3| -> |9| -> |9| Digit is: 1399 1399 + 1 = 1400 Output: |1| -> |4| -> |0| -> |0| Input: |9| -> |9| -> |9| -> |9| Output: |1| -> |0| -> |0| -> |0| -> |0|","title":"Add One in Lisked List Digit"},{"location":"linked_list/add_one_linked_list_digit.html#implementation","text":"package main import \"fmt\" func main() { head := initialize(19999) head = addOne(head) printResult(head) } func initialize(n int) (head *Node) { var arr []int for n > 0 { data := n % 10 arr = append(arr, data) n = n / 10 } var curr *Node for i := len(arr) - 1; i >= 0; i-- { if i == len(arr)-1 { curr = &Node{data: arr[i]} head = curr } else { curr.next = &Node{data: arr[i]} curr = curr.next } } return head } func printResult(head *Node) { for head != nil { fmt.Print(head.data) head = head.next } fmt.Println() } type Node struct { data int next *Node } func addOne(head *Node) *Node { var stack []*Node curr := head for curr != nil { stack = append(stack, curr) curr = curr.next } carry := 1 for i := len(stack) - 1; i >= 0; i-- { ele := stack[i] add := ele.data + carry ele.data = add % 10 carry = add / 10 } if carry > 0 { newHead := &Node{data: carry} newHead.next = head return newHead } return head }","title":"Implementation"},{"location":"linked_list/delete_middle_ele_linked_list.html","text":"Delete Middle Element of Singly Linked List Input: 1 -> 2 -> 3 -> 4 -> 5 Output: 1 -> 2 -> 4 -> 5 Note: If there are odd number of element then delete middle Input: 1 -> 2 -> 3 -> 4 Output: 1 -> 2 -> 4 Note: If there are even number of element then there will be two middle elements. So we will delete second middle. Implementation package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} deleteMiddle(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func deleteMiddle(head *Node) { fast := head slow := head pre := head for fast != nil && fast.next != nil { pre = slow slow = slow.next fast = fast.next.next } pre.next = slow.next }","title":"Delete Middle Element of Singly Linked List"},{"location":"linked_list/delete_middle_ele_linked_list.html#delete-middle-element-of-singly-linked-list","text":"Input: 1 -> 2 -> 3 -> 4 -> 5 Output: 1 -> 2 -> 4 -> 5 Note: If there are odd number of element then delete middle Input: 1 -> 2 -> 3 -> 4 Output: 1 -> 2 -> 4 Note: If there are even number of element then there will be two middle elements. So we will delete second middle.","title":"Delete Middle Element of Singly Linked List"},{"location":"linked_list/delete_middle_ele_linked_list.html#implementation","text":"package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} deleteMiddle(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func deleteMiddle(head *Node) { fast := head slow := head pre := head for fast != nil && fast.next != nil { pre = slow slow = slow.next fast = fast.next.next } pre.next = slow.next }","title":"Implementation"},{"location":"linked_list/reserve_singly_linked_list.html","text":"Reverse a Singly Linked List Input: 1 -> 2 -> 3 -> 4-> 5 OutPut: 5 -> 4 -> 3 -> 2 -> 1 Implementation package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} head = reverse(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func reverse(head *Node) *Node { curr := head var temp *Node = nil var pre *Node = nil for curr != nil { temp = curr.next curr.next = pre pre = curr curr = temp } return pre }","title":"Reverse A Singly Linked List"},{"location":"linked_list/reserve_singly_linked_list.html#reverse-a-singly-linked-list","text":"Input: 1 -> 2 -> 3 -> 4-> 5 OutPut: 5 -> 4 -> 3 -> 2 -> 1","title":"Reverse a Singly Linked List"},{"location":"linked_list/reserve_singly_linked_list.html#implementation","text":"package main import \"fmt\" type Node struct { data int next *Node } func main() { head := &Node{data: 1} head.next = &Node{data: 2} head.next.next = &Node{data: 3} head.next.next.next = &Node{data: 4} head.next.next.next.next = &Node{data: 5} head = reverse(head) for head != nil { fmt.Printf(\"%d \", head.data) head = head.next } fmt.Println() } func reverse(head *Node) *Node { curr := head var temp *Node = nil var pre *Node = nil for curr != nil { temp = curr.next curr.next = pre pre = curr curr = temp } return pre }","title":"Implementation"},{"location":"searching/binary_search.html","text":"Binary Search Iterative package main import \"fmt\" func main() { // idx := search([]int{1, 2, 3, 4, 5}, 6) //-1 idx := search([]int{1, 2, 3, 4, 5}, 3) // 2 fmt.Println(idx) } func search(nums []int, target int) int { low := 0 high := len(nums) - 1 for low <= high { mid := (low + high) / 2 if nums[mid] == target { return mid } else if nums[mid] < target { low = mid + 1 } else { high = mid - 1 } } return -1 } Recursive package main import \"fmt\" func main() { // idx := searchRec([]int{1, 2, 3, 4, 5}, 0, 4, 6) // -1 idx := searchRec([]int{1, 2, 3, 4, 5}, 0, 4, 3) // 2 fmt.Println(idx) } func searchRec(nums []int, low, high, target int) int { if low > high { return -1 } mid := (low + high) / 2 if nums[mid] == target { return mid } else if nums[mid] < target { return searchRec(nums, mid+1, high, target) } else { return searchRec(nums, low, mid-1, target) } }","title":"Binary Search"},{"location":"searching/binary_search.html#binary-search","text":"","title":"Binary Search"},{"location":"searching/binary_search.html#iterative","text":"package main import \"fmt\" func main() { // idx := search([]int{1, 2, 3, 4, 5}, 6) //-1 idx := search([]int{1, 2, 3, 4, 5}, 3) // 2 fmt.Println(idx) } func search(nums []int, target int) int { low := 0 high := len(nums) - 1 for low <= high { mid := (low + high) / 2 if nums[mid] == target { return mid } else if nums[mid] < target { low = mid + 1 } else { high = mid - 1 } } return -1 }","title":"Iterative"},{"location":"searching/binary_search.html#recursive","text":"package main import \"fmt\" func main() { // idx := searchRec([]int{1, 2, 3, 4, 5}, 0, 4, 6) // -1 idx := searchRec([]int{1, 2, 3, 4, 5}, 0, 4, 3) // 2 fmt.Println(idx) } func searchRec(nums []int, low, high, target int) int { if low > high { return -1 } mid := (low + high) / 2 if nums[mid] == target { return mid } else if nums[mid] < target { return searchRec(nums, mid+1, high, target) } else { return searchRec(nums, low, mid-1, target) } }","title":"Recursive"},{"location":"simple/all_divisors_of_a_number.html","text":"All Divisors Of A Number","title":"All Divisors Of A Number"},{"location":"simple/all_divisors_of_a_number.html#all-divisors-of-a-number","text":"","title":"All Divisors Of A Number"},{"location":"simple/check_for_prime.html","text":"Check for Prime","title":"Check for Prime"},{"location":"simple/check_for_prime.html#check-for-prime","text":"","title":"Check for Prime"},{"location":"simple/computing_power_x_n.html","text":"Computing Power(x,n)","title":"Computing Power(x,n)"},{"location":"simple/computing_power_x_n.html#computing-powerxn","text":"","title":"Computing Power(x,n)"},{"location":"simple/count_digit.html","text":"Count Digit Input: a := 1234 Output: 4 Input: a := 98 Output: 2 Input: a := 5 Output: 1 where a > 0 Using Loop package main import \"fmt\" func main() { d := digitCount(99999) fmt.Println(d) } func digitCount(n int) int { result := 0 for n > 0 { result++ n = n / 10 } return result } Dry Run d = 123 Initially result = 0 After 1st Iteration: x = 12 and res=1 After 2nd Iteration: x = 1 and res=2 After 3rd Iteration: x = 0 and res=3 Time Complexity: \u03b8(d) where d is number of digits Using Logarithm package main import ( \"fmt\" \"math\" ) func main() { n := 99999 d := int(math.Log10(float64(n))) + 1 fmt.Println(d) }","title":"Count Digits"},{"location":"simple/count_digit.html#count-digit","text":"Input: a := 1234 Output: 4 Input: a := 98 Output: 2 Input: a := 5 Output: 1 where a > 0","title":"Count Digit"},{"location":"simple/count_digit.html#using-loop","text":"package main import \"fmt\" func main() { d := digitCount(99999) fmt.Println(d) } func digitCount(n int) int { result := 0 for n > 0 { result++ n = n / 10 } return result } Dry Run d = 123 Initially result = 0 After 1st Iteration: x = 12 and res=1 After 2nd Iteration: x = 1 and res=2 After 3rd Iteration: x = 0 and res=3 Time Complexity: \u03b8(d) where d is number of digits","title":"Using Loop"},{"location":"simple/count_digit.html#using-logarithm","text":"package main import ( \"fmt\" \"math\" ) func main() { n := 99999 d := int(math.Log10(float64(n))) + 1 fmt.Println(d) }","title":"Using Logarithm"},{"location":"simple/factorial_of_number.html","text":"Factorial of A Number Input: n = 4 Output: 24 Input: n = 6 Output: 760 Input: n = 0 Output: 1 Iterative Approach package main import \"fmt\" func main() { res := fact(6) fmt.Println(res) } func fact(n int) int { res := 1 for i := 2; i < n; i++ { res = res * i } return res } Time Complexity: \u03b8(n) Aux Space Complexity: \u03b8(1) Recursive Approach package main import \"fmt\" func main() { f := fact(4) fmt.Println(f) } func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1) } Time Complexity: \u03b8(n) Aux Space Complexity: \u03b8(n)","title":"Factorial of A Number"},{"location":"simple/factorial_of_number.html#factorial-of-a-number","text":"Input: n = 4 Output: 24 Input: n = 6 Output: 760 Input: n = 0 Output: 1","title":"Factorial of A Number"},{"location":"simple/factorial_of_number.html#iterative-approach","text":"package main import \"fmt\" func main() { res := fact(6) fmt.Println(res) } func fact(n int) int { res := 1 for i := 2; i < n; i++ { res = res * i } return res } Time Complexity: \u03b8(n) Aux Space Complexity: \u03b8(1)","title":"Iterative Approach"},{"location":"simple/factorial_of_number.html#recursive-approach","text":"package main import \"fmt\" func main() { f := fact(4) fmt.Println(f) } func fact(n int) int { if n == 0 { return 1 } return n * fact(n-1) } Time Complexity: \u03b8(n) Aux Space Complexity: \u03b8(n)","title":"Recursive Approach"},{"location":"simple/greatest_common_divisor.html","text":"","title":"Greatest Common Divisor"},{"location":"simple/iterative_power_binary_exponentiation.html","text":"","title":"Iterative Power (Binary Exponentiation)"},{"location":"simple/lcm_of_two_numbers.html","text":"LCM of Two Numbers","title":"LCM of Two Numbers"},{"location":"simple/lcm_of_two_numbers.html#lcm-of-two-numbers","text":"","title":"LCM of Two Numbers"},{"location":"simple/palindrome_numbers.html","text":"Palindrome Numbers A number is palindrome if its reverse is same as number. Number is >=0 A single digit number is always a palindrome number. Input: n = 12321 Output: Yes Input: n = 2332 Output: Yes Input: n = 5 Output: Yes Input: n = 34 Output: No Input: n = 123 Output: No Implementation package main import ( \"fmt\" ) func main() { // res := isPalindrome(12321) // true // res := isPalindrome(1221) // true res := isPalindrome(123) // false fmt.Println(res) } func isPalindrome(n int) bool { rev := 0 temp := n for temp != 0 { lastDigit := temp % 10 rev = rev*10 + lastDigit temp = temp / 10 } return rev == n }","title":"Palindrome Numbers"},{"location":"simple/palindrome_numbers.html#palindrome-numbers","text":"A number is palindrome if its reverse is same as number. Number is >=0 A single digit number is always a palindrome number. Input: n = 12321 Output: Yes Input: n = 2332 Output: Yes Input: n = 5 Output: Yes Input: n = 34 Output: No Input: n = 123 Output: No","title":"Palindrome Numbers"},{"location":"simple/palindrome_numbers.html#implementation","text":"package main import ( \"fmt\" ) func main() { // res := isPalindrome(12321) // true // res := isPalindrome(1221) // true res := isPalindrome(123) // false fmt.Println(res) } func isPalindrome(n int) bool { rev := 0 temp := n for temp != 0 { lastDigit := temp % 10 rev = rev*10 + lastDigit temp = temp / 10 } return rev == n }","title":"Implementation"},{"location":"simple/prime_factors.html","text":"Prime Factors","title":"Prime Factors"},{"location":"simple/prime_factors.html#prime-factors","text":"","title":"Prime Factors"},{"location":"simple/sieve_of_eratosthenes.html","text":"Sieve of Eratosthenes","title":"Sieve of Eratosthenes"},{"location":"simple/sieve_of_eratosthenes.html#sieve-of-eratosthenes","text":"","title":"Sieve of Eratosthenes"},{"location":"simple/trailing_zeros_in_factorial.html","text":"Trailing Zeros in Factorial Input: n = 5 Output: 1 Explaination: 1 * 2 * 3 * 4 * 5 = 120. We have one trailing zero in 120 Input: n = 10 Output: 2 Explaination: 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800. We have two trailing zero in 3628800 Input: n = 10 Output: 2 Explaination: 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800. We have two trailing zero in 3628800 Input: n = 100 Output: 24 Explaination: 1 * 2 * 3 * 4 * 5 ..... 98 * 99 * 100 = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 . We have 24 trailing zero in this number Naive Approach package main import \"fmt\" func main() { res := trailingZeroInFact(10) fmt.Println(res) } func trailingZeroInFact(n int) int { fact := 1 for i := 2; i <= n; i++ { fact = fact * i } res := 0 for fact%10 == 0 { res++ fact = fact / 10 } return res } Time Complexity: \u03b8(n) Dry Run: n = 10 fact = 3628800 res = 0 After 1st iteration: res = 1, fact=362880 After 2nd iteration: res = 2, fact=36288 Limitation: Causes value overflow for even for slightly higher value. Ex: n = 21, the factoring will be 20 digits. So it will be larger than int value in golang. Efficient Approach","title":"Trailing Zeros in Factorial"},{"location":"simple/trailing_zeros_in_factorial.html#trailing-zeros-in-factorial","text":"Input: n = 5 Output: 1 Explaination: 1 * 2 * 3 * 4 * 5 = 120. We have one trailing zero in 120 Input: n = 10 Output: 2 Explaination: 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800. We have two trailing zero in 3628800 Input: n = 10 Output: 2 Explaination: 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 = 3628800. We have two trailing zero in 3628800 Input: n = 100 Output: 24 Explaination: 1 * 2 * 3 * 4 * 5 ..... 98 * 99 * 100 = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 . We have 24 trailing zero in this number","title":"Trailing Zeros in Factorial"},{"location":"simple/trailing_zeros_in_factorial.html#naive-approach","text":"package main import \"fmt\" func main() { res := trailingZeroInFact(10) fmt.Println(res) } func trailingZeroInFact(n int) int { fact := 1 for i := 2; i <= n; i++ { fact = fact * i } res := 0 for fact%10 == 0 { res++ fact = fact / 10 } return res } Time Complexity: \u03b8(n) Dry Run: n = 10 fact = 3628800 res = 0 After 1st iteration: res = 1, fact=362880 After 2nd iteration: res = 2, fact=36288 Limitation: Causes value overflow for even for slightly higher value. Ex: n = 21, the factoring will be 20 digits. So it will be larger than int value in golang.","title":"Naive Approach"},{"location":"simple/trailing_zeros_in_factorial.html#efficient-approach","text":"","title":"Efficient Approach"},{"location":"sorting/bubble_sort.html","text":"Bubble Sort Bubble sort is stable It is in-place Naive Approach package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: \u03b8(n*n) Efficient Approach If array is already sorted or get sorted in middle of iteration. package main import \"fmt\" func main() { // arr := []int{10, 3, 25, 17, 21, 55} arr := []int{3, 10, 17, 21, 25, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { swapped := false for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) swapped = true } } if !swapped { break } } } func swap(a, b int) (int, int) { return b, a }","title":"Bubble Sort"},{"location":"sorting/bubble_sort.html#bubble-sort","text":"Bubble sort is stable It is in-place","title":"Bubble Sort"},{"location":"sorting/bubble_sort.html#naive-approach","text":"package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) } } } } func swap(a, b int) (int, int) { return b, a } Time Complexity: \u03b8(n*n)","title":"Naive Approach"},{"location":"sorting/bubble_sort.html#efficient-approach","text":"If array is already sorted or get sorted in middle of iteration. package main import \"fmt\" func main() { // arr := []int{10, 3, 25, 17, 21, 55} arr := []int{3, 10, 17, 21, 25, 55} bubbleSort(arr) fmt.Println(arr) } func bubbleSort(arr []int) { for i := 0; i < len(arr); i++ { swapped := false for j := 0; j < len(arr)-i-1; j++ { if arr[j] > arr[j+1] { arr[j], arr[j+1] = swap(arr[j], arr[j+1]) swapped = true } } if !swapped { break } } } func swap(a, b int) (int, int) { return b, a }","title":"Efficient Approach"},{"location":"sorting/insertion_sort.html","text":"Insertion Sort O(n 2 ) In-place and stable Used in practice for small array (Tim Sort and Intro Sort) O(n) in best case Note: It divides array into two sub array. 0 to i-1 is sorted and i to n-1 is unsorted. Since 0th element already sorted in 0-0 subarray, so we have started with i=1 package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} insertionSort(arr) fmt.Println(arr) } func insertionSort(arr []int) { for i := 1; i < len(arr); i++ { key := arr[i] j := i - 1 for j >= 0 && arr[j] > key { arr[j+1] = arr[j] j-- } arr[j+1] = key } } Time Complexity Best Case: \u03b8(n) if already sorted Worst Case: \u03b8(n 2 ) if it is reverse sorted In General: O(n 2 )","title":"Insertion Sort"},{"location":"sorting/insertion_sort.html#insertion-sort","text":"O(n 2 ) In-place and stable Used in practice for small array (Tim Sort and Intro Sort) O(n) in best case Note: It divides array into two sub array. 0 to i-1 is sorted and i to n-1 is unsorted. Since 0th element already sorted in 0-0 subarray, so we have started with i=1 package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} insertionSort(arr) fmt.Println(arr) } func insertionSort(arr []int) { for i := 1; i < len(arr); i++ { key := arr[i] j := i - 1 for j >= 0 && arr[j] > key { arr[j+1] = arr[j] j-- } arr[j+1] = key } } Time Complexity Best Case: \u03b8(n) if already sorted Worst Case: \u03b8(n 2 ) if it is reverse sorted In General: O(n 2 )","title":"Insertion Sort"},{"location":"sorting/introduction.html","text":"Introduction Stability of Sorting Algorithm A sorting algorithm is stable if it ensures the orignal order if 2 items has same value Example of stable sorts Bubble Sort Insertion Sort Merge Sort Example of unstable sorts Selection Sort Quick Sort Heap Sorts","title":"Introduction"},{"location":"sorting/introduction.html#introduction","text":"","title":"Introduction"},{"location":"sorting/introduction.html#stability-of-sorting-algorithm","text":"A sorting algorithm is stable if it ensures the orignal order if 2 items has same value Example of stable sorts Bubble Sort Insertion Sort Merge Sort Example of unstable sorts Selection Sort Quick Sort Heap Sorts","title":"Stability of Sorting Algorithm"},{"location":"sorting/merge_sort.html","text":"Merge Sort Introduction Divide and Conquer Algorithm Divide Conquer Merge Stable Algorithm \u03b8(n log n) time and O(n) aux space Well suited for linked list. Works in O(1) aux space Used in external sorting In generate for array. Quick sort outperforms it. Merge Two Sorted Array Input: a[] = {12, 17, 22} b[] = {7, 8, 8, 17} Ouput: c[] = {7, 8, 8, 12, 17, 22} Input: a[] = {11, 11, 22} b[] = {33} Ouput: c[] = {11, 11, 22, 33} Naive Solution package main import ( \"fmt\" \"sort\" ) type Person struct { id int name string } func main() { a := []int{10, 15, 20, 20} b := []int{1, 2, 13} c := merge(a, b) fmt.Println(c) } func merge(a []int, b []int) []int { c := make([]int, len(a)+len(b)) for i, ele := range a { c[i] = ele } for i, ele := range b { c[len(a)+i] = ele } sort.Ints(c) return c } Time Complexity: O((m+n) log(m+n)) Space Complexity: \u03b8(m+n) Dry Run: a[] = {10, 15, 20, 20} b[] = {1, 2, 13} After 1st Loop: c[] = {10, 15, 20, 20, , , _} After 2st Loop: c[] = {10, 15, 20, 20, 1, 2, 13} After Sorting: c[] = {1, 2, 10, 13, 15, 20, 20} Efficient Solution Initially i=0, j =0 if a[i] <= b[j] { append a[i]; i++} else append b[j]; j++ package main import \"fmt\" func main() { a := []int{5, 10, 15, 20} b := []int{10, 20, 30} res := merge(a, b) fmt.Println(res) } func merge(a []int, b []int) (result []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if a[i] <= b[j] { result = append(result, a[i]) i++ } else { result = append(result, b[j]) j++ } } for i < len(a) { result = append(result, a[i]) i++ } for j < len(b) { result = append(result, b[j]) j++ } return } Time Complexity: \u03b8(m+n) Dry Run: a := {5, 10, 15, 20} b := {10, 20, 30} First Loop i=0, j=0 c[]={5} i=1 c[]={5, 10} i=2 c[]={5, 10, 10} j=1 c[]={5, 10, 10, 15} i=3 c[]={5, 10, 10, 15, 20} i=4 Second Loop Nothing Third Loop c[]={5, 10, 10, 15, 20, 20} j=2 c[]={5, 10, 10, 15, 20, 20, 30} j=3 Merge Function of Merge Sort Input: a[] = {12, 15, 22, 13, 32} |---------| |-----| low = 0 mid = 2 high = 4 Output: a[] = {12, 13, 17 , 22, 32} Input: a[] = {7, 10, 12, 14, 9} |-------------| |--| low = 0 mid = 3 high = 4 Output: a[] = {7, 10, 12, 14, 9} Implementation Idea a[] = {13, 18, 21, 45, 10, 15, 80} low = 0 mid = 3 high = 6 left[] = {13, 18, 21, 45} right[] = { 10, 15, 80} merge left and right array a[] = {10, 13, 15, 18, 21, 45, 80} Implementation func merge(a []int, low int, mid int, high int) { // Setting up auxilary array n1 := mid - low + 1 n2 := high - mid left := make([]int, n1) right := make([]int, n2) for i := 0; i < n1; i++ { left[i] = a[low+i] } for i := 0; i < n2; i++ { right[i] = a[mid+i+1] } // standard merge logic i := 0 j := 0 k := low for i < n1 && j < n2 { if left[i] < right[j] { a[k] = left[i] i++ k++ } else { a[k] = right[j] k++ j++ } } for i < n1 { a[k] = left[i] k++ i++ } for j < n2 { a[k] = right[j] k++ j++ } } Time complexity: \u03b8(n) Aux Space: \u03b8(n) Merge Sort Algorithm func mergeSort(arr []int, l, r int) { if r > l { // atleast 2 elements m := (l + r) / 2 mergeSort(arr, l, m) mergeSort(arr, m+1, r) merge(arr, l, m, r) } } Explaination Merge Sort Analysis","title":"Merge Sort"},{"location":"sorting/merge_sort.html#merge-sort","text":"","title":"Merge Sort"},{"location":"sorting/merge_sort.html#introduction","text":"Divide and Conquer Algorithm Divide Conquer Merge Stable Algorithm \u03b8(n log n) time and O(n) aux space Well suited for linked list. Works in O(1) aux space Used in external sorting In generate for array. Quick sort outperforms it.","title":"Introduction"},{"location":"sorting/merge_sort.html#merge-two-sorted-array","text":"Input: a[] = {12, 17, 22} b[] = {7, 8, 8, 17} Ouput: c[] = {7, 8, 8, 12, 17, 22} Input: a[] = {11, 11, 22} b[] = {33} Ouput: c[] = {11, 11, 22, 33}","title":"Merge Two Sorted Array"},{"location":"sorting/merge_sort.html#naive-solution","text":"package main import ( \"fmt\" \"sort\" ) type Person struct { id int name string } func main() { a := []int{10, 15, 20, 20} b := []int{1, 2, 13} c := merge(a, b) fmt.Println(c) } func merge(a []int, b []int) []int { c := make([]int, len(a)+len(b)) for i, ele := range a { c[i] = ele } for i, ele := range b { c[len(a)+i] = ele } sort.Ints(c) return c } Time Complexity: O((m+n) log(m+n)) Space Complexity: \u03b8(m+n) Dry Run: a[] = {10, 15, 20, 20} b[] = {1, 2, 13} After 1st Loop: c[] = {10, 15, 20, 20, , , _} After 2st Loop: c[] = {10, 15, 20, 20, 1, 2, 13} After Sorting: c[] = {1, 2, 10, 13, 15, 20, 20}","title":"Naive Solution"},{"location":"sorting/merge_sort.html#efficient-solution","text":"Initially i=0, j =0 if a[i] <= b[j] { append a[i]; i++} else append b[j]; j++ package main import \"fmt\" func main() { a := []int{5, 10, 15, 20} b := []int{10, 20, 30} res := merge(a, b) fmt.Println(res) } func merge(a []int, b []int) (result []int) { i := 0 j := 0 for i < len(a) && j < len(b) { if a[i] <= b[j] { result = append(result, a[i]) i++ } else { result = append(result, b[j]) j++ } } for i < len(a) { result = append(result, a[i]) i++ } for j < len(b) { result = append(result, b[j]) j++ } return } Time Complexity: \u03b8(m+n) Dry Run: a := {5, 10, 15, 20} b := {10, 20, 30} First Loop i=0, j=0 c[]={5} i=1 c[]={5, 10} i=2 c[]={5, 10, 10} j=1 c[]={5, 10, 10, 15} i=3 c[]={5, 10, 10, 15, 20} i=4 Second Loop Nothing Third Loop c[]={5, 10, 10, 15, 20, 20} j=2 c[]={5, 10, 10, 15, 20, 20, 30} j=3","title":"Efficient Solution"},{"location":"sorting/merge_sort.html#merge-function-of-merge-sort","text":"Input: a[] = {12, 15, 22, 13, 32} |---------| |-----| low = 0 mid = 2 high = 4 Output: a[] = {12, 13, 17 , 22, 32} Input: a[] = {7, 10, 12, 14, 9} |-------------| |--| low = 0 mid = 3 high = 4 Output: a[] = {7, 10, 12, 14, 9}","title":"Merge Function of Merge Sort"},{"location":"sorting/merge_sort.html#implementation-idea","text":"a[] = {13, 18, 21, 45, 10, 15, 80} low = 0 mid = 3 high = 6 left[] = {13, 18, 21, 45} right[] = { 10, 15, 80} merge left and right array a[] = {10, 13, 15, 18, 21, 45, 80}","title":"Implementation Idea"},{"location":"sorting/merge_sort.html#implementation","text":"func merge(a []int, low int, mid int, high int) { // Setting up auxilary array n1 := mid - low + 1 n2 := high - mid left := make([]int, n1) right := make([]int, n2) for i := 0; i < n1; i++ { left[i] = a[low+i] } for i := 0; i < n2; i++ { right[i] = a[mid+i+1] } // standard merge logic i := 0 j := 0 k := low for i < n1 && j < n2 { if left[i] < right[j] { a[k] = left[i] i++ k++ } else { a[k] = right[j] k++ j++ } } for i < n1 { a[k] = left[i] k++ i++ } for j < n2 { a[k] = right[j] k++ j++ } } Time complexity: \u03b8(n) Aux Space: \u03b8(n)","title":"Implementation"},{"location":"sorting/merge_sort.html#merge-sort-algorithm","text":"func mergeSort(arr []int, l, r int) { if r > l { // atleast 2 elements m := (l + r) / 2 mergeSort(arr, l, m) mergeSort(arr, m+1, r) merge(arr, l, m, r) } }","title":"Merge Sort Algorithm"},{"location":"sorting/merge_sort.html#explaination","text":"","title":"Explaination"},{"location":"sorting/merge_sort.html#merge-sort-analysis","text":"","title":"Merge Sort Analysis"},{"location":"sorting/quick_sort.html","text":"Quick Sort Partition a Given Array Input: arr[] = {13, 16, 22, 20, 17} pivot = 5 Output: arr[] = {13, 16, 17, 22, 20} or arr[] = {16, 13, 17, 22, 20} return value: 2 It is a new index of pivot element Stability in Partition \u251c\u2500\u2500 Stable \u2502 \u2514\u2500\u2500 Naive Partition \u2514\u2500\u2500 Not Stable \u251c\u2500\u2500 Lomuto Partition \u2514\u2500\u2500 Hoare's Partition Naive Partition Input: arr[] = {12, 17, 18, 13, 17} pivot = 1 or 4 Output: arr[] = {12, 13, 17, 17, 18} return value = 3 Note: Please note in the return value on above example that we return the last index of 17 i.e. 3, even our pivot is 1 or 4. So we need to return the last occurrence of pivot element as explained in above example. Implementation package main import \"fmt\" func main() { arr := []int{30, 80, 40, 90, 10, 50, 70} p := partition(arr, 0, len(arr)-1, len(arr)-1) fmt.Println(p) // 4 fmt.Println(arr) // [30 40 10 50 70 80 90] } func partition(arr []int, l, h, p int) int { temp := make([]int, h-l+1) // create temp array idx := 0 for i := l; i <= h; i++ { if arr[i] < arr[p] { temp[idx] = arr[i] //Smaller in temp array idx++ } } for i := l; i <= h; i++ { if arr[i] == arr[p] { temp[idx] = arr[i] // equal elements in temp. We could do thi sin first loop but we need this loop for stability idx++ } } res := l + idx - 1 // last ocurrance of pivot for i := l; i <= h; i++ { if arr[i] > arr[p] { temp[idx] = arr[i] // greator elements in temp idx++ } } for i := l; i <= h; i++ { arr[i] = temp[i] // copy to original array } return res } Complexity Time Complexity: \u03b8(n) Aux Space Complexity: \u03b8(n) Dry Run arr[] = {5, 3, 12, 8, 5} l=0, h=4, p=0 After 1st loop temp[] = {3, , , , } After 2nd loop temp[] = {3, 5, 5, , } After 3nd loop temp[] = {3, 5, 5, 12, 8} After 4th loop arr[] = {3, 5, 5, 12, 8} Lomuto Partition arr[] = {10, 80, 30, 90, 40, 50, 70} l=0, h=6, pivot=70 Lomuto partition always selects the last element s pivot element. As above diagram explains, the Lomuto partition moves < pivot elements into 0 --> i section and keeps >=pivot elements intp i --> j section. Implementation package main import \"fmt\" func main() { arr := []int{30, 80, 10, 90, 40, 50, 70} p := lomutoPartition(arr, 0, len(arr)-1) fmt.Println(p) fmt.Println(arr) } func lomutoPartition(arr []int, l, h int) int { p := arr[h] i := l - 1 for j := l; j < h; j++ { if arr[j] < p { i++ arr[i], arr[j] = arr[j], arr[i] } } arr[i+1], arr[h] = arr[h], arr[i+1] return i + 1 } Complexity Time Complexity: O(n) Aux Space Complexity: O(1) Dry run Cornor cases Dry run yourself: {70, 60, 80, 40, 30} ==> No small value than pivot {30, 40, 20, 50, 80} ==> No large value than pivot","title":"Quick Sort"},{"location":"sorting/quick_sort.html#quick-sort","text":"","title":"Quick Sort"},{"location":"sorting/quick_sort.html#partition-a-given-array","text":"Input: arr[] = {13, 16, 22, 20, 17} pivot = 5 Output: arr[] = {13, 16, 17, 22, 20} or arr[] = {16, 13, 17, 22, 20} return value: 2 It is a new index of pivot element Stability in Partition \u251c\u2500\u2500 Stable \u2502 \u2514\u2500\u2500 Naive Partition \u2514\u2500\u2500 Not Stable \u251c\u2500\u2500 Lomuto Partition \u2514\u2500\u2500 Hoare's Partition","title":"Partition a Given Array"},{"location":"sorting/quick_sort.html#naive-partition","text":"Input: arr[] = {12, 17, 18, 13, 17} pivot = 1 or 4 Output: arr[] = {12, 13, 17, 17, 18} return value = 3 Note: Please note in the return value on above example that we return the last index of 17 i.e. 3, even our pivot is 1 or 4. So we need to return the last occurrence of pivot element as explained in above example.","title":"Naive Partition"},{"location":"sorting/quick_sort.html#implementation","text":"package main import \"fmt\" func main() { arr := []int{30, 80, 40, 90, 10, 50, 70} p := partition(arr, 0, len(arr)-1, len(arr)-1) fmt.Println(p) // 4 fmt.Println(arr) // [30 40 10 50 70 80 90] } func partition(arr []int, l, h, p int) int { temp := make([]int, h-l+1) // create temp array idx := 0 for i := l; i <= h; i++ { if arr[i] < arr[p] { temp[idx] = arr[i] //Smaller in temp array idx++ } } for i := l; i <= h; i++ { if arr[i] == arr[p] { temp[idx] = arr[i] // equal elements in temp. We could do thi sin first loop but we need this loop for stability idx++ } } res := l + idx - 1 // last ocurrance of pivot for i := l; i <= h; i++ { if arr[i] > arr[p] { temp[idx] = arr[i] // greator elements in temp idx++ } } for i := l; i <= h; i++ { arr[i] = temp[i] // copy to original array } return res }","title":"Implementation"},{"location":"sorting/quick_sort.html#complexity","text":"Time Complexity: \u03b8(n) Aux Space Complexity: \u03b8(n)","title":"Complexity"},{"location":"sorting/quick_sort.html#dry-run","text":"arr[] = {5, 3, 12, 8, 5} l=0, h=4, p=0 After 1st loop temp[] = {3, , , , } After 2nd loop temp[] = {3, 5, 5, , } After 3nd loop temp[] = {3, 5, 5, 12, 8} After 4th loop arr[] = {3, 5, 5, 12, 8}","title":"Dry Run"},{"location":"sorting/quick_sort.html#lomuto-partition","text":"arr[] = {10, 80, 30, 90, 40, 50, 70} l=0, h=6, pivot=70 Lomuto partition always selects the last element s pivot element. As above diagram explains, the Lomuto partition moves < pivot elements into 0 --> i section and keeps >=pivot elements intp i --> j section.","title":"Lomuto Partition"},{"location":"sorting/quick_sort.html#implementation_1","text":"package main import \"fmt\" func main() { arr := []int{30, 80, 10, 90, 40, 50, 70} p := lomutoPartition(arr, 0, len(arr)-1) fmt.Println(p) fmt.Println(arr) } func lomutoPartition(arr []int, l, h int) int { p := arr[h] i := l - 1 for j := l; j < h; j++ { if arr[j] < p { i++ arr[i], arr[j] = arr[j], arr[i] } } arr[i+1], arr[h] = arr[h], arr[i+1] return i + 1 }","title":"Implementation"},{"location":"sorting/quick_sort.html#complexity_1","text":"Time Complexity: O(n) Aux Space Complexity: O(1)","title":"Complexity"},{"location":"sorting/quick_sort.html#dry-run_1","text":"","title":"Dry run"},{"location":"sorting/quick_sort.html#cornor-cases","text":"Dry run yourself: {70, 60, 80, 40, 30} ==> No small value than pivot {30, 40, 20, 50, 80} ==> No large value than pivot","title":"Cornor cases"},{"location":"sorting/selection_sort.html","text":"Selection Sort \u03b8(n 2 ) Algorithm Does less memory writes compared to quick sort, merge sort, insertion sor etc. But cycle sort is optimal in terms of memory writes Basic idea for heap sort Not stable In place: Does not require extra memory for sorting package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} selectionSort(arr) fmt.Println(arr) } func selectionSort(arr []int) { for i := 0; i < len(arr)-1; i++ { min_idx := i for j := i + 1; j < len(arr); j++ { if arr[j] < arr[min_idx] { min_idx = j } } arr[i], arr[min_idx] = arr[min_idx], arr[i] } } Time Complexity : \u03b8(n 2 ) Q. Why is it not stable. Ans: Given an array: arr[] = {90, 95, 90, 101 } 90 at 0th index will be swapped with 90 at 3rd index. So orginal order is not maintain when two elements are equal.","title":"Selection Sort"},{"location":"sorting/selection_sort.html#selection-sort","text":"\u03b8(n 2 ) Algorithm Does less memory writes compared to quick sort, merge sort, insertion sor etc. But cycle sort is optimal in terms of memory writes Basic idea for heap sort Not stable In place: Does not require extra memory for sorting package main import \"fmt\" func main() { arr := []int{10, 3, 25, 17, 21, 55} // arr := []int{3, 10, 17, 21, 25, 55} selectionSort(arr) fmt.Println(arr) } func selectionSort(arr []int) { for i := 0; i < len(arr)-1; i++ { min_idx := i for j := i + 1; j < len(arr); j++ { if arr[j] < arr[min_idx] { min_idx = j } } arr[i], arr[min_idx] = arr[min_idx], arr[i] } } Time Complexity : \u03b8(n 2 ) Q. Why is it not stable. Ans: Given an array: arr[] = {90, 95, 90, 101 } 90 at 0th index will be swapped with 90 at 3rd index. So orginal order is not maintain when two elements are equal.","title":"Selection Sort"},{"location":"string/all_permutation.html","text":"All Permutation of A String","title":"All Permutation of A String"},{"location":"string/all_permutation.html#all-permutation-of-a-string","text":"","title":"All Permutation of A String"},{"location":"string/anagram.html","text":"Check If Two Given Strings are Anagram or Not Example of anagram strings: Listen == Silent Triangle == Integral William Shakespeare == I am a weakish speller Note: The string may contain punctuations. You need to ignore punctuations Implementation package main import ( \"fmt\" \"strings\" ) func main() { str1 := \"William Shakespeare.\" str2 := \" I am a weakish speller\" res := anagram(str1, str2) fmt.Println(res) } func anagram(str1, str2 string) bool { r1 := []rune(strings.ToLower(str1)) r2 := []rune(strings.ToLower(str2)) m1 := make(map[rune]int) for _, ele := range r1 { if (ele >= 97 && ele <= 122) || (ele >= 65 && ele <= 90) { m1[ele] = m1[ele] + 1 } } m2 := make(map[rune]int) for _, ele := range r2 { if (ele >= 97 && ele <= 122) || (ele >= 65 && ele <= 90) { m2[ele] = m2[ele] + 1 } } if len(m1) != len(m2) { return false } for key, val := range m1 { if val != m2[key] { return false } } return true }","title":"Strign is Anagram"},{"location":"string/anagram.html#check-if-two-given-strings-are-anagram-or-not","text":"Example of anagram strings: Listen == Silent Triangle == Integral William Shakespeare == I am a weakish speller Note: The string may contain punctuations. You need to ignore punctuations","title":"Check If Two Given Strings are Anagram or Not"},{"location":"string/anagram.html#implementation","text":"package main import ( \"fmt\" \"strings\" ) func main() { str1 := \"William Shakespeare.\" str2 := \" I am a weakish speller\" res := anagram(str1, str2) fmt.Println(res) } func anagram(str1, str2 string) bool { r1 := []rune(strings.ToLower(str1)) r2 := []rune(strings.ToLower(str2)) m1 := make(map[rune]int) for _, ele := range r1 { if (ele >= 97 && ele <= 122) || (ele >= 65 && ele <= 90) { m1[ele] = m1[ele] + 1 } } m2 := make(map[rune]int) for _, ele := range r2 { if (ele >= 97 && ele <= 122) || (ele >= 65 && ele <= 90) { m2[ele] = m2[ele] + 1 } } if len(m1) != len(m2) { return false } for key, val := range m1 { if val != m2[key] { return false } } return true }","title":"Implementation"},{"location":"string/max_word_n_count.html","text":"Max occured word by d in given paragraph","title":"Max n Occurance of Word in Paragraph"},{"location":"string/max_word_n_count.html#max-occured-word-by-d-in-given-paragraph","text":"","title":"Max occured word by d in given paragraph"},{"location":"string/palindrom.html","text":"Check if a String is Palindrom or not Efficient Approach package main import \"fmt\" func main() { str := \"\u65e5\u672c\u8a9e\u672c\u65e5\" // true // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\" // false // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\u65e5\" // true // str := \"madam\" // true // str := \"maddam\" // true result := isPalindram(str) fmt.Println(result) } func isPalindram(str string) bool { chars := []rune(str) for i := 0; i < len(chars)/2; i++ { revIdx := len(chars) - i - 1 if chars[i] != chars[revIdx] { return false } } return true }","title":"String is Palindrom"},{"location":"string/palindrom.html#check-if-a-string-is-palindrom-or-not","text":"","title":"Check if a String is Palindrom or not"},{"location":"string/palindrom.html#efficient-approach","text":"package main import \"fmt\" func main() { str := \"\u65e5\u672c\u8a9e\u672c\u65e5\" // true // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\" // false // str := \"\u65e5\u672c\u8a9e\u8a9e\u672c\u65e5\" // true // str := \"madam\" // true // str := \"maddam\" // true result := isPalindram(str) fmt.Println(result) } func isPalindram(str string) bool { chars := []rune(str) for i := 0; i < len(chars)/2; i++ { revIdx := len(chars) - i - 1 if chars[i] != chars[revIdx] { return false } } return true }","title":"Efficient Approach"},{"location":"string/pangram.html","text":"Check if a String is Pangram or not A string is pangram if string contain a-z / A-Z alphabets alteast once. You can ignore the case. You need to consider only english alphabets and the string may contain punctuation marks. Also, you need to return how number of letter are missing if it is not pangram. Example of angram string: 1. The quick brown fox jumps over a lazy dog. 2. Mr. Jock, TV quiz PhD., bags few lynx. Initial Solution package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over a lazy dog.\" // true 0 // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true 0 // str := \"The quick brown fox jumps over the dog\" // false 4 result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, int) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } if len(charMap) == 26 { return true, 0 } return false, 26 - len(charMap) } Enhancement It should also show missing letters. package main import ( \"fmt\" \"strings\" ) func main() { // str := \"The quick brown fox jumps over a lazy dog.\" // true [] // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true [] str := \"The quick brown fox jumps over the dog\" // false [a l y z] result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, []string) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } var missingAlpha []string var i rune = 'a' for ; i <= 'z'; i++ { if !(charMap[string(i)]) { missingAlpha = append(missingAlpha, string(i)) } } if len(missingAlpha) == 0 { return true, missingAlpha } return false, missingAlpha }","title":"String is Pangram"},{"location":"string/pangram.html#check-if-a-string-is-pangram-or-not","text":"A string is pangram if string contain a-z / A-Z alphabets alteast once. You can ignore the case. You need to consider only english alphabets and the string may contain punctuation marks. Also, you need to return how number of letter are missing if it is not pangram. Example of angram string: 1. The quick brown fox jumps over a lazy dog. 2. Mr. Jock, TV quiz PhD., bags few lynx.","title":"Check if a String is Pangram or not"},{"location":"string/pangram.html#initial-solution","text":"package main import ( \"fmt\" \"strings\" ) func main() { str := \"The quick brown fox jumps over a lazy dog.\" // true 0 // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true 0 // str := \"The quick brown fox jumps over the dog\" // false 4 result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, int) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } if len(charMap) == 26 { return true, 0 } return false, 26 - len(charMap) }","title":"Initial Solution"},{"location":"string/pangram.html#enhancement","text":"It should also show missing letters. package main import ( \"fmt\" \"strings\" ) func main() { // str := \"The quick brown fox jumps over a lazy dog.\" // true [] // str := \"Mr. Jock, TV quiz PhD., bags few lynx.\" // true [] str := \"The quick brown fox jumps over the dog\" // false [a l y z] result, count := isPangram(str) fmt.Println(result, count) } func isPangram(str string) (bool, []string) { charMap := make(map[string]bool) for _, ele := range str { if (ele >= 'A' && ele <= 'Z') || (ele >= 'a' && ele <= 'z') { char := strings.ToLower(string(ele)) charMap[char] = true } } var missingAlpha []string var i rune = 'a' for ; i <= 'z'; i++ { if !(charMap[string(i)]) { missingAlpha = append(missingAlpha, string(i)) } } if len(missingAlpha) == 0 { return true, missingAlpha } return false, missingAlpha }","title":"Enhancement"},{"location":"string/subsequence.html","text":"Print All subssequence of the string Subsequence is not substring subsequence string can be generated by selecting charactor from the given string It should maintain the order Valid subsequence: abc and acd are subsequence of abcd Invalid subsequence: acb and dac is not subsequence of abcd because order is not maintained Ex1: Input: abcd Outout: [abcd abc abd ab acd ac ad a bcd bc bd b cd c d ] package main import \"fmt\" var arr []string func main() { arr = make([]string, 0) str := \"abcd\" subseq(str, \"\") fmt.Println(arr) } func subseq(str, ans string) { if len(str) == 0 { arr = append(arr, ans) return } firstChar := string([]rune(str)[0]) subseq(str[1:], ans+firstChar) subseq(str[1:], ans) }","title":"All subsequence of A string"},{"location":"string/subsequence.html#print-all-subssequence-of-the-string","text":"Subsequence is not substring subsequence string can be generated by selecting charactor from the given string It should maintain the order Valid subsequence: abc and acd are subsequence of abcd Invalid subsequence: acb and dac is not subsequence of abcd because order is not maintained Ex1: Input: abcd Outout: [abcd abc abd ab acd ac ad a bcd bc bd b cd c d ] package main import \"fmt\" var arr []string func main() { arr = make([]string, 0) str := \"abcd\" subseq(str, \"\") fmt.Println(arr) } func subseq(str, ans string) { if len(str) == 0 { arr = append(arr, ans) return } firstChar := string([]rune(str)[0]) subseq(str[1:], ans+firstChar) subseq(str[1:], ans) }","title":"Print All subssequence of the string"},{"location":"string/word_count.html","text":"Word count(ocurance of each word) in given paragraph","title":"Word cound in paragraph"},{"location":"string/word_count.html#word-countocurance-of-each-word-in-given-paragraph","text":"","title":"Word count(ocurance of each word) in given paragraph"}]}